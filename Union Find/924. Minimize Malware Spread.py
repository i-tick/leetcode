from collections import defaultdict
from typing import List


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        par = [i for i in range(n)]
        rank = [1 for _ in range(n)]
        def find(i):
            if i!=par[i]:
                par[i] = find(par[i])
            return par[i]
        
        def union(i,j):
            p1 = find(i)
            p2 = find(j)

            if p1!=p2:
                par[max(p1,p2)] = min(p1,p2)
                rank[min(p1,p2)] += rank[max(p1,p2)]
            
        for i in range(n):
            for j in range(n):
                if graph[i][j]:
                    union(i,j)

        maximum_size, candidate_node = 0, min(initial)
        infected = defaultdict(int)
        for i in initial:
            infected[find(i)] += 1
        
        for i in initial:
            infection_count = infected[find(i)]
            component_size = rank[find(i)]

            if infection_count != 1:
                continue
            
            if component_size > maximum_size:
                maximum_size = component_size
                candidate_node = i
            elif component_size == maximum_size and i < candidate_node:
                candidate_node = i
        return candidate_node
            
# Time Complexity: O(n^2) for the union-find operations, where n is the number of nodes in the graph.
# Space Complexity: O(n) for the parent and rank arrays, where n is the number of nodes in the graph.
# The algorithm efficiently processes the graph to determine the minimum malware spread by leveraging union-find to group connected components.